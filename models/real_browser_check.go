// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// RealBrowserCheck A Real Browser check
//
// swagger:model real_browser_check
type RealBrowserCheck struct {
	MonitoringCheck

	// When true, the check will keep using the default, up-to-date User Agent for the selected browser. Default value is false
	AutoUpdateUserAgent *AutoUpdateUserAgent `json:"auto_update_user_agent,omitempty"`

	// browser
	Browser *Browser `json:"browser,omitempty"`

	// Network connection settings to simulate different types of networks.
	Connection *Connection `json:"connection,omitempty"`

	// cookies
	Cookies []*Cookie `json:"cookies"`

	// Key-value pairs specifying the original host (key) and replacement host (value)
	// Example: {"original.domain.com":"new.domain.com","original.host.com":"123.456.789.1"}
	DNSOverrides interface{} `json:"dns_overrides,omitempty"`

	// enforce ssl validation
	EnforceSslValidation *EnforceSslValidation `json:"enforce_ssl_validation,omitempty"`

	// excluded files
	ExcludedFiles []*ExcludedFile `json:"excluded_files"`

	// A list of JavaScript files attached to this check
	JavascriptFiles []*JavascriptFile `json:"javascript_files"`

	// A list of steps to take when this check runs
	Steps []*RealBrowserCheckStep `json:"steps"`

	// threshold monitors
	ThresholdMonitors []*ThresholdMonitor `json:"threshold_monitors"`

	// url
	URL StartURL `json:"url,omitempty"`

	// The User Agent string that helps identify which browser is being used
	UserAgent UserAgent `json:"user_agent,omitempty"`

	// viewport
	Viewport *Viewport `json:"viewport,omitempty"`

	// Wait for full metrics to become available before proceeding with steps. When disabled, steps will proceed earlier but some metrics may be missing.
	WaitForFullMetrics *bool `json:"wait_for_full_metrics,omitempty"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *RealBrowserCheck) UnmarshalJSON(raw []byte) error {
	// AO0
	var aO0 MonitoringCheck
	if err := swag.ReadJSON(raw, &aO0); err != nil {
		return err
	}
	m.MonitoringCheck = aO0

	// AO1
	var dataAO1 struct {
		AutoUpdateUserAgent *AutoUpdateUserAgent `json:"auto_update_user_agent,omitempty"`

		Browser *Browser `json:"browser,omitempty"`

		Connection *Connection `json:"connection,omitempty"`

		Cookies []*Cookie `json:"cookies"`

		DNSOverrides interface{} `json:"dns_overrides,omitempty"`

		EnforceSslValidation *EnforceSslValidation `json:"enforce_ssl_validation,omitempty"`

		ExcludedFiles []*ExcludedFile `json:"excluded_files"`

		JavascriptFiles []*JavascriptFile `json:"javascript_files"`

		Steps []*RealBrowserCheckStep `json:"steps"`

		ThresholdMonitors []*ThresholdMonitor `json:"threshold_monitors"`

		URL StartURL `json:"url,omitempty"`

		UserAgent UserAgent `json:"user_agent,omitempty"`

		Viewport *Viewport `json:"viewport,omitempty"`

		WaitForFullMetrics *bool `json:"wait_for_full_metrics,omitempty"`
	}
	if err := swag.ReadJSON(raw, &dataAO1); err != nil {
		return err
	}

	m.AutoUpdateUserAgent = dataAO1.AutoUpdateUserAgent

	m.Browser = dataAO1.Browser

	m.Connection = dataAO1.Connection

	m.Cookies = dataAO1.Cookies

	m.DNSOverrides = dataAO1.DNSOverrides

	m.EnforceSslValidation = dataAO1.EnforceSslValidation

	m.ExcludedFiles = dataAO1.ExcludedFiles

	m.JavascriptFiles = dataAO1.JavascriptFiles

	m.Steps = dataAO1.Steps

	m.ThresholdMonitors = dataAO1.ThresholdMonitors

	m.URL = dataAO1.URL

	m.UserAgent = dataAO1.UserAgent

	m.Viewport = dataAO1.Viewport

	m.WaitForFullMetrics = dataAO1.WaitForFullMetrics

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m RealBrowserCheck) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 2)

	aO0, err := swag.WriteJSON(m.MonitoringCheck)
	if err != nil {
		return nil, err
	}
	_parts = append(_parts, aO0)
	var dataAO1 struct {
		AutoUpdateUserAgent *AutoUpdateUserAgent `json:"auto_update_user_agent,omitempty"`

		Browser *Browser `json:"browser,omitempty"`

		Connection *Connection `json:"connection,omitempty"`

		Cookies []*Cookie `json:"cookies"`

		DNSOverrides interface{} `json:"dns_overrides,omitempty"`

		EnforceSslValidation *EnforceSslValidation `json:"enforce_ssl_validation,omitempty"`

		ExcludedFiles []*ExcludedFile `json:"excluded_files"`

		JavascriptFiles []*JavascriptFile `json:"javascript_files"`

		Steps []*RealBrowserCheckStep `json:"steps"`

		ThresholdMonitors []*ThresholdMonitor `json:"threshold_monitors"`

		URL StartURL `json:"url,omitempty"`

		UserAgent UserAgent `json:"user_agent,omitempty"`

		Viewport *Viewport `json:"viewport,omitempty"`

		WaitForFullMetrics *bool `json:"wait_for_full_metrics,omitempty"`
	}

	dataAO1.AutoUpdateUserAgent = m.AutoUpdateUserAgent

	dataAO1.Browser = m.Browser

	dataAO1.Connection = m.Connection

	dataAO1.Cookies = m.Cookies

	dataAO1.DNSOverrides = m.DNSOverrides

	dataAO1.EnforceSslValidation = m.EnforceSslValidation

	dataAO1.ExcludedFiles = m.ExcludedFiles

	dataAO1.JavascriptFiles = m.JavascriptFiles

	dataAO1.Steps = m.Steps

	dataAO1.ThresholdMonitors = m.ThresholdMonitors

	dataAO1.URL = m.URL

	dataAO1.UserAgent = m.UserAgent

	dataAO1.Viewport = m.Viewport

	dataAO1.WaitForFullMetrics = m.WaitForFullMetrics

	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1)
	if errAO1 != nil {
		return nil, errAO1
	}
	_parts = append(_parts, jsonDataAO1)
	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this real browser check
func (m *RealBrowserCheck) Validate(formats strfmt.Registry) error {
	var res []error

	// validation for a type composition with MonitoringCheck
	if err := m.MonitoringCheck.Validate(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAutoUpdateUserAgent(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBrowser(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateConnection(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCookies(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEnforceSslValidation(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateExcludedFiles(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateJavascriptFiles(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSteps(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateThresholdMonitors(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateURL(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUserAgent(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateViewport(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RealBrowserCheck) validateAutoUpdateUserAgent(formats strfmt.Registry) error {

	if swag.IsZero(m.AutoUpdateUserAgent) { // not required
		return nil
	}

	if m.AutoUpdateUserAgent != nil {
		if err := m.AutoUpdateUserAgent.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("auto_update_user_agent")
			}
			return err
		}
	}

	return nil
}

func (m *RealBrowserCheck) validateBrowser(formats strfmt.Registry) error {

	if swag.IsZero(m.Browser) { // not required
		return nil
	}

	if m.Browser != nil {
		if err := m.Browser.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("browser")
			}
			return err
		}
	}

	return nil
}

func (m *RealBrowserCheck) validateConnection(formats strfmt.Registry) error {

	if swag.IsZero(m.Connection) { // not required
		return nil
	}

	if m.Connection != nil {
		if err := m.Connection.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("connection")
			}
			return err
		}
	}

	return nil
}

func (m *RealBrowserCheck) validateCookies(formats strfmt.Registry) error {

	if swag.IsZero(m.Cookies) { // not required
		return nil
	}

	for i := 0; i < len(m.Cookies); i++ {
		if swag.IsZero(m.Cookies[i]) { // not required
			continue
		}

		if m.Cookies[i] != nil {
			if err := m.Cookies[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("cookies" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *RealBrowserCheck) validateEnforceSslValidation(formats strfmt.Registry) error {

	if swag.IsZero(m.EnforceSslValidation) { // not required
		return nil
	}

	if m.EnforceSslValidation != nil {
		if err := m.EnforceSslValidation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("enforce_ssl_validation")
			}
			return err
		}
	}

	return nil
}

func (m *RealBrowserCheck) validateExcludedFiles(formats strfmt.Registry) error {

	if swag.IsZero(m.ExcludedFiles) { // not required
		return nil
	}

	for i := 0; i < len(m.ExcludedFiles); i++ {
		if swag.IsZero(m.ExcludedFiles[i]) { // not required
			continue
		}

		if m.ExcludedFiles[i] != nil {
			if err := m.ExcludedFiles[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("excluded_files" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *RealBrowserCheck) validateJavascriptFiles(formats strfmt.Registry) error {

	if swag.IsZero(m.JavascriptFiles) { // not required
		return nil
	}

	for i := 0; i < len(m.JavascriptFiles); i++ {
		if swag.IsZero(m.JavascriptFiles[i]) { // not required
			continue
		}

		if m.JavascriptFiles[i] != nil {
			if err := m.JavascriptFiles[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("javascript_files" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *RealBrowserCheck) validateSteps(formats strfmt.Registry) error {

	if swag.IsZero(m.Steps) { // not required
		return nil
	}

	for i := 0; i < len(m.Steps); i++ {
		if swag.IsZero(m.Steps[i]) { // not required
			continue
		}

		if m.Steps[i] != nil {
			if err := m.Steps[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("steps" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *RealBrowserCheck) validateThresholdMonitors(formats strfmt.Registry) error {

	if swag.IsZero(m.ThresholdMonitors) { // not required
		return nil
	}

	for i := 0; i < len(m.ThresholdMonitors); i++ {
		if swag.IsZero(m.ThresholdMonitors[i]) { // not required
			continue
		}

		if m.ThresholdMonitors[i] != nil {
			if err := m.ThresholdMonitors[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("threshold_monitors" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *RealBrowserCheck) validateURL(formats strfmt.Registry) error {

	if swag.IsZero(m.URL) { // not required
		return nil
	}

	if err := m.URL.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("url")
		}
		return err
	}

	return nil
}

func (m *RealBrowserCheck) validateUserAgent(formats strfmt.Registry) error {

	if swag.IsZero(m.UserAgent) { // not required
		return nil
	}

	if err := m.UserAgent.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("user_agent")
		}
		return err
	}

	return nil
}

func (m *RealBrowserCheck) validateViewport(formats strfmt.Registry) error {

	if swag.IsZero(m.Viewport) { // not required
		return nil
	}

	if m.Viewport != nil {
		if err := m.Viewport.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("viewport")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this real browser check based on the context it is used
func (m *RealBrowserCheck) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	// validation for a type composition with MonitoringCheck
	if err := m.MonitoringCheck.ContextValidate(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateAutoUpdateUserAgent(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateBrowser(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateConnection(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCookies(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateEnforceSslValidation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateExcludedFiles(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateJavascriptFiles(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSteps(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateThresholdMonitors(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateURL(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateUserAgent(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateViewport(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *RealBrowserCheck) contextValidateAutoUpdateUserAgent(ctx context.Context, formats strfmt.Registry) error {

	if m.AutoUpdateUserAgent != nil {
		if err := m.AutoUpdateUserAgent.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("auto_update_user_agent")
			}
			return err
		}
	}

	return nil
}

func (m *RealBrowserCheck) contextValidateBrowser(ctx context.Context, formats strfmt.Registry) error {

	if m.Browser != nil {
		if err := m.Browser.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("browser")
			}
			return err
		}
	}

	return nil
}

func (m *RealBrowserCheck) contextValidateConnection(ctx context.Context, formats strfmt.Registry) error {

	if m.Connection != nil {
		if err := m.Connection.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("connection")
			}
			return err
		}
	}

	return nil
}

func (m *RealBrowserCheck) contextValidateCookies(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Cookies); i++ {

		if m.Cookies[i] != nil {
			if err := m.Cookies[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("cookies" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *RealBrowserCheck) contextValidateEnforceSslValidation(ctx context.Context, formats strfmt.Registry) error {

	if m.EnforceSslValidation != nil {
		if err := m.EnforceSslValidation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("enforce_ssl_validation")
			}
			return err
		}
	}

	return nil
}

func (m *RealBrowserCheck) contextValidateExcludedFiles(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ExcludedFiles); i++ {

		if m.ExcludedFiles[i] != nil {
			if err := m.ExcludedFiles[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("excluded_files" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *RealBrowserCheck) contextValidateJavascriptFiles(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.JavascriptFiles); i++ {

		if m.JavascriptFiles[i] != nil {
			if err := m.JavascriptFiles[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("javascript_files" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *RealBrowserCheck) contextValidateSteps(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Steps); i++ {

		if m.Steps[i] != nil {
			if err := m.Steps[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("steps" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *RealBrowserCheck) contextValidateThresholdMonitors(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ThresholdMonitors); i++ {

		if m.ThresholdMonitors[i] != nil {
			if err := m.ThresholdMonitors[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("threshold_monitors" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *RealBrowserCheck) contextValidateURL(ctx context.Context, formats strfmt.Registry) error {

	if err := m.URL.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("url")
		}
		return err
	}

	return nil
}

func (m *RealBrowserCheck) contextValidateUserAgent(ctx context.Context, formats strfmt.Registry) error {

	if err := m.UserAgent.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("user_agent")
		}
		return err
	}

	return nil
}

func (m *RealBrowserCheck) contextValidateViewport(ctx context.Context, formats strfmt.Registry) error {

	if m.Viewport != nil {
		if err := m.Viewport.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("viewport")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *RealBrowserCheck) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *RealBrowserCheck) UnmarshalBinary(b []byte) error {
	var res RealBrowserCheck
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
