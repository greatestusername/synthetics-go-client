// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"bytes"
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// MonitoringCheck A monitoring check
//
// swagger:model monitoring_check
type MonitoringCheck struct {
	createdAtField strfmt.DateTime

	frequencyField int64

	idField *int32

	linksField *CheckLinks

	mutedField bool

	nameField string

	pausedField bool

	statusField *Status

	tagsField []*Tag

	updatedAtField strfmt.DateTime

	// When enabled, the check will retry up to two times from the same location after a failed run. Ensure your account plan supports this feature before enabling.
	AutoRetry *bool `json:"auto_retry,omitempty"`

	// blackout periods
	BlackoutPeriods []interface{} `json:"blackout_periods"`

	// True if the check is not paused
	Enabled *bool `json:"enabled,omitempty"`

	// http request headers
	HTTPRequestHeaders interface{} `json:"http_request_headers,omitempty"`

	// The integrations to send metrics to
	Integrations []*Integration `json:"integrations"`

	// The locations to run the check from
	Locations []*Location `json:"locations"`

	// notifications
	Notifications *Notifications `json:"notifications,omitempty"`

	// Mark a run as a failure if the total response time
	//                                    is above this threshold (in milliseconds)
	// Maximum: 60000
	// Minimum: 0
	ResponseTimeMonitorMilliseconds *int32 `json:"response_time_monitor_milliseconds,omitempty"`

	// When enabled, the check cycles through locations round-robin style with each run.Ensure your account plan supports concurrent checks before disabling.
	RoundRobin bool `json:"round_robin,omitempty"`
}

// CreatedAt gets the created at of this subtype
func (m *MonitoringCheck) CreatedAt() strfmt.DateTime {
	return m.createdAtField
}

// SetCreatedAt sets the created at of this subtype
func (m *MonitoringCheck) SetCreatedAt(val strfmt.DateTime) {
	m.createdAtField = val
}

// Frequency gets the frequency of this subtype
func (m *MonitoringCheck) Frequency() int64 {
	return m.frequencyField
}

// SetFrequency sets the frequency of this subtype
func (m *MonitoringCheck) SetFrequency(val int64) {
	m.frequencyField = val
}

// ID gets the id of this subtype
func (m *MonitoringCheck) ID() *int32 {
	return m.idField
}

// SetID sets the id of this subtype
func (m *MonitoringCheck) SetID(val *int32) {
	m.idField = val
}

// Links gets the links of this subtype
func (m *MonitoringCheck) Links() *CheckLinks {
	return m.linksField
}

// SetLinks sets the links of this subtype
func (m *MonitoringCheck) SetLinks(val *CheckLinks) {
	m.linksField = val
}

// Muted gets the muted of this subtype
func (m *MonitoringCheck) Muted() bool {
	return m.mutedField
}

// SetMuted sets the muted of this subtype
func (m *MonitoringCheck) SetMuted(val bool) {
	m.mutedField = val
}

// Name gets the name of this subtype
func (m *MonitoringCheck) Name() string {
	return m.nameField
}

// SetName sets the name of this subtype
func (m *MonitoringCheck) SetName(val string) {
	m.nameField = val
}

// Paused gets the paused of this subtype
func (m *MonitoringCheck) Paused() bool {
	return m.pausedField
}

// SetPaused sets the paused of this subtype
func (m *MonitoringCheck) SetPaused(val bool) {
	m.pausedField = val
}

// Status gets the status of this subtype
func (m *MonitoringCheck) Status() *Status {
	return m.statusField
}

// SetStatus sets the status of this subtype
func (m *MonitoringCheck) SetStatus(val *Status) {
	m.statusField = val
}

// Tags gets the tags of this subtype
func (m *MonitoringCheck) Tags() []*Tag {
	return m.tagsField
}

// SetTags sets the tags of this subtype
func (m *MonitoringCheck) SetTags(val []*Tag) {
	m.tagsField = val
}

// Type gets the type of this subtype
func (m *MonitoringCheck) Type() string {
	return "monitoring_check"
}

// SetType sets the type of this subtype
func (m *MonitoringCheck) SetType(val string) {
}

// UpdatedAt gets the updated at of this subtype
func (m *MonitoringCheck) UpdatedAt() strfmt.DateTime {
	return m.updatedAtField
}

// SetUpdatedAt sets the updated at of this subtype
func (m *MonitoringCheck) SetUpdatedAt(val strfmt.DateTime) {
	m.updatedAtField = val
}

// UnmarshalJSON unmarshals this object with a polymorphic type from a JSON structure
func (m *MonitoringCheck) UnmarshalJSON(raw []byte) error {
	var data struct {

		// When enabled, the check will retry up to two times from the same location after a failed run. Ensure your account plan supports this feature before enabling.
		AutoRetry *bool `json:"auto_retry,omitempty"`

		// blackout periods
		BlackoutPeriods []interface{} `json:"blackout_periods"`

		// True if the check is not paused
		Enabled *bool `json:"enabled,omitempty"`

		// http request headers
		HTTPRequestHeaders interface{} `json:"http_request_headers,omitempty"`

		// The integrations to send metrics to
		Integrations []*Integration `json:"integrations"`

		// The locations to run the check from
		Locations []*Location `json:"locations"`

		// notifications
		Notifications *Notifications `json:"notifications,omitempty"`

		// Mark a run as a failure if the total response time
		//                                    is above this threshold (in milliseconds)
		// Maximum: 60000
		// Minimum: 0
		ResponseTimeMonitorMilliseconds *int32 `json:"response_time_monitor_milliseconds,omitempty"`

		// When enabled, the check cycles through locations round-robin style with each run.Ensure your account plan supports concurrent checks before disabling.
		RoundRobin bool `json:"round_robin,omitempty"`
	}
	buf := bytes.NewBuffer(raw)
	dec := json.NewDecoder(buf)
	dec.UseNumber()

	if err := dec.Decode(&data); err != nil {
		return err
	}

	var base struct {
		/* Just the base type fields. Used for unmashalling polymorphic types.*/

		CreatedAt strfmt.DateTime `json:"created_at,omitempty"`

		Frequency int64 `json:"frequency,omitempty"`

		ID *int32 `json:"id"`

		Links *CheckLinks `json:"links,omitempty"`

		Muted bool `json:"muted,omitempty"`

		Name string `json:"name,omitempty"`

		Paused bool `json:"paused,omitempty"`

		Status *Status `json:"status,omitempty"`

		Tags []*Tag `json:"tags"`

		Type string `json:"type"`

		UpdatedAt strfmt.DateTime `json:"updated_at,omitempty"`
	}
	buf = bytes.NewBuffer(raw)
	dec = json.NewDecoder(buf)
	dec.UseNumber()

	if err := dec.Decode(&base); err != nil {
		return err
	}

	var result MonitoringCheck

	result.createdAtField = base.CreatedAt

	result.frequencyField = base.Frequency

	result.idField = base.ID

	result.linksField = base.Links

	result.mutedField = base.Muted

	result.nameField = base.Name

	result.pausedField = base.Paused

	result.statusField = base.Status

	result.tagsField = base.Tags

	if base.Type != result.Type() {
		/* Not the type we're looking for. */
		return errors.New(422, "invalid type value: %q", base.Type)
	}
	result.updatedAtField = base.UpdatedAt

	result.AutoRetry = data.AutoRetry
	result.BlackoutPeriods = data.BlackoutPeriods
	result.Enabled = data.Enabled
	result.HTTPRequestHeaders = data.HTTPRequestHeaders
	result.Integrations = data.Integrations
	result.Locations = data.Locations
	result.Notifications = data.Notifications
	result.ResponseTimeMonitorMilliseconds = data.ResponseTimeMonitorMilliseconds
	result.RoundRobin = data.RoundRobin

	*m = result

	return nil
}

// MarshalJSON marshals this object with a polymorphic type to a JSON structure
func (m MonitoringCheck) MarshalJSON() ([]byte, error) {
	var b1, b2, b3 []byte
	var err error
	b1, err = json.Marshal(struct {

		// When enabled, the check will retry up to two times from the same location after a failed run. Ensure your account plan supports this feature before enabling.
		AutoRetry *bool `json:"auto_retry,omitempty"`

		// blackout periods
		BlackoutPeriods []interface{} `json:"blackout_periods"`

		// True if the check is not paused
		Enabled *bool `json:"enabled,omitempty"`

		// http request headers
		HTTPRequestHeaders interface{} `json:"http_request_headers,omitempty"`

		// The integrations to send metrics to
		Integrations []*Integration `json:"integrations"`

		// The locations to run the check from
		Locations []*Location `json:"locations"`

		// notifications
		Notifications *Notifications `json:"notifications,omitempty"`

		// Mark a run as a failure if the total response time
		//                                    is above this threshold (in milliseconds)
		// Maximum: 60000
		// Minimum: 0
		ResponseTimeMonitorMilliseconds *int32 `json:"response_time_monitor_milliseconds,omitempty"`

		// When enabled, the check cycles through locations round-robin style with each run.Ensure your account plan supports concurrent checks before disabling.
		RoundRobin bool `json:"round_robin,omitempty"`
	}{

		AutoRetry: m.AutoRetry,

		BlackoutPeriods: m.BlackoutPeriods,

		Enabled: m.Enabled,

		HTTPRequestHeaders: m.HTTPRequestHeaders,

		Integrations: m.Integrations,

		Locations: m.Locations,

		Notifications: m.Notifications,

		ResponseTimeMonitorMilliseconds: m.ResponseTimeMonitorMilliseconds,

		RoundRobin: m.RoundRobin,
	})
	if err != nil {
		return nil, err
	}
	b2, err = json.Marshal(struct {
		CreatedAt strfmt.DateTime `json:"created_at,omitempty"`

		Frequency int64 `json:"frequency,omitempty"`

		ID *int32 `json:"id"`

		Links *CheckLinks `json:"links,omitempty"`

		Muted bool `json:"muted,omitempty"`

		Name string `json:"name,omitempty"`

		Paused bool `json:"paused,omitempty"`

		Status *Status `json:"status,omitempty"`

		Tags []*Tag `json:"tags"`

		Type string `json:"type"`

		UpdatedAt strfmt.DateTime `json:"updated_at,omitempty"`
	}{

		CreatedAt: m.CreatedAt(),

		Frequency: m.Frequency(),

		ID: m.ID(),

		Links: m.Links(),

		Muted: m.Muted(),

		Name: m.Name(),

		Paused: m.Paused(),

		Status: m.Status(),

		Tags: m.Tags(),

		Type: m.Type(),

		UpdatedAt: m.UpdatedAt(),
	})
	if err != nil {
		return nil, err
	}

	return swag.ConcatJSON(b1, b2, b3), nil
}

// Validate validates this monitoring check
func (m *MonitoringCheck) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCreatedAt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTags(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUpdatedAt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIntegrations(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLocations(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNotifications(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateResponseTimeMonitorMilliseconds(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MonitoringCheck) validateCreatedAt(formats strfmt.Registry) error {

	if swag.IsZero(m.CreatedAt()) { // not required
		return nil
	}

	if err := validate.FormatOf("created_at", "body", "date-time", m.CreatedAt().String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *MonitoringCheck) validateID(formats strfmt.Registry) error {

	if err := validate.Required("id", "body", m.ID()); err != nil {
		return err
	}

	return nil
}

func (m *MonitoringCheck) validateLinks(formats strfmt.Registry) error {

	if swag.IsZero(m.Links()) { // not required
		return nil
	}

	if m.Links() != nil {
		if err := m.Links().Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("links")
			}
			return err
		}
	}

	return nil
}

func (m *MonitoringCheck) validateStatus(formats strfmt.Registry) error {

	if swag.IsZero(m.Status()) { // not required
		return nil
	}

	if m.Status() != nil {
		if err := m.Status().Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("status")
			}
			return err
		}
	}

	return nil
}

func (m *MonitoringCheck) validateTags(formats strfmt.Registry) error {

	if swag.IsZero(m.Tags()) { // not required
		return nil
	}

	for i := 0; i < len(m.Tags()); i++ {
		if swag.IsZero(m.tagsField[i]) { // not required
			continue
		}

		if m.tagsField[i] != nil {
			if err := m.tagsField[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("tags" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *MonitoringCheck) validateUpdatedAt(formats strfmt.Registry) error {

	if swag.IsZero(m.UpdatedAt()) { // not required
		return nil
	}

	if err := validate.FormatOf("updated_at", "body", "date-time", m.UpdatedAt().String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *MonitoringCheck) validateIntegrations(formats strfmt.Registry) error {

	if swag.IsZero(m.Integrations) { // not required
		return nil
	}

	for i := 0; i < len(m.Integrations); i++ {
		if swag.IsZero(m.Integrations[i]) { // not required
			continue
		}

		if m.Integrations[i] != nil {
			if err := m.Integrations[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("integrations" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *MonitoringCheck) validateLocations(formats strfmt.Registry) error {

	if swag.IsZero(m.Locations) { // not required
		return nil
	}

	for i := 0; i < len(m.Locations); i++ {
		if swag.IsZero(m.Locations[i]) { // not required
			continue
		}

		if m.Locations[i] != nil {
			if err := m.Locations[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("locations" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *MonitoringCheck) validateNotifications(formats strfmt.Registry) error {

	if swag.IsZero(m.Notifications) { // not required
		return nil
	}

	if m.Notifications != nil {
		if err := m.Notifications.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("notifications")
			}
			return err
		}
	}

	return nil
}

func (m *MonitoringCheck) validateResponseTimeMonitorMilliseconds(formats strfmt.Registry) error {

	if swag.IsZero(m.ResponseTimeMonitorMilliseconds) { // not required
		return nil
	}

	if err := validate.MinimumInt("response_time_monitor_milliseconds", "body", int64(*m.ResponseTimeMonitorMilliseconds), 0, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("response_time_monitor_milliseconds", "body", int64(*m.ResponseTimeMonitorMilliseconds), 60000, false); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this monitoring check based on the context it is used
func (m *MonitoringCheck) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStatus(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTags(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIntegrations(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLocations(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNotifications(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *MonitoringCheck) contextValidateLinks(ctx context.Context, formats strfmt.Registry) error {

	if m.Links() != nil {
		if err := m.Links().ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("links")
			}
			return err
		}
	}

	return nil
}

func (m *MonitoringCheck) contextValidateStatus(ctx context.Context, formats strfmt.Registry) error {

	if m.Status() != nil {
		if err := m.Status().ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("status")
			}
			return err
		}
	}

	return nil
}

func (m *MonitoringCheck) contextValidateTags(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Tags()); i++ {

		if m.tagsField[i] != nil {
			if err := m.tagsField[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("tags" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *MonitoringCheck) contextValidateIntegrations(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Integrations); i++ {

		if m.Integrations[i] != nil {
			if err := m.Integrations[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("integrations" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *MonitoringCheck) contextValidateLocations(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Locations); i++ {

		if m.Locations[i] != nil {
			if err := m.Locations[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("locations" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *MonitoringCheck) contextValidateNotifications(ctx context.Context, formats strfmt.Registry) error {

	if m.Notifications != nil {
		if err := m.Notifications.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("notifications")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *MonitoringCheck) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *MonitoringCheck) UnmarshalBinary(b []byte) error {
	var res MonitoringCheck
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
